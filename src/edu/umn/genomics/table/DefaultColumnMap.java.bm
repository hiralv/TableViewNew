
package edu.umn.genomics.table;

import java.io.Serializable;
import java.lang.ref.*;
import java.util.*;
import java.text.DecimalFormat;
import java.text.ParsePosition;
import javax.swing.*;
import javax.swing.table.*;
import javax.swing.event.*;
import edu.umn.genomics.graph.LineFormula;

/**
 * DefaultColumnMap maps the values of a TableModel column to a numeric range.
 * If Class type of the column is Number, or if all of the values of the 
 * column are Strings that can be parsed as class Number, the range will 
 * be from the minimum to the maximun of the values in the column. 
 * If any value can not be parsed as class Number, the values will be mapped 
 * to integral values from 0 to the number of distinct values - 1,
 * (distinct values are determined by the value's equals method.)
 * The DefaultColumnMap can also be used to select a range of mapped values 
 * from the column and indicate the selected rows in a ListSelectionModel.  
 * A new selection is be specified as a subrange of values between the
 * the minimum and maximum values of the column.
 * New selections may be combined with the previous selections using standard 
 * set operators.
 * 
 * @author       J Johnson
 * @version      %I%, %G%
 * @since        1.0
 * @see  SetOperator 
 * @see  javax.swing.table.TableModel 
 * @see  javax.swing.ListSelectionModel
 */
public class DefaultColumnMap implements Serializable, ColumnMap, 
                                         TableModelListener {
  static boolean async = true;
  static boolean canRef = false;
  static {
    try {
      Class.forName("java.lang.ref.SoftReference");
      //canRef = true;
    } catch (ClassNotFoundException cnfe) {
    }
  }
  class Elem {      // class to hold info in colHash
    Object obj = null;
    int index = 0;  // ordinal for distinct values in this column
    int count = 0;  // count of rows that have this value
    Elem(int index) {
      this.index = index;
    }
  }
  TableModel tm = null;
  ListSelectionModel lsm = null;
  private EventListenerList listenerList = new EventListenerList();
  int setOperator = SetOperator.REPLACE;
  int c = 0;
  boolean tryNumber = true; // try to map as Number, else map as Object
  boolean isNumber = false; // whether all elements are of type Number
  boolean isDate =   false; // whether all elements are Dates
  boolean colTyped = false; // the type of the elememts has been determined.
  Class colClass = null;
  int colType = 0;
  static int defaultsortby = NATURALSORT;
  int sortby = defaultsortby;
  double range[] = new double[2]; 
  double dvals[] = null;
  Hashtable colHash = null; // map element Object to an Elem object
  Elem elements[] = null;
  int rowCount = 0;
  boolean remap = false;
  boolean recalc = true;
  // stats
  double median = Double.NaN;
  double q1 = Double.NaN;
  double q3 = Double.NaN;
  double mean = Double.NaN;
  double variance = Double.NaN;
  double stddev = Double.NaN;
  int numNull = -1;
  int numDistinct = -1;
  private static final String nullTag = "\"\"";
  String name = null;
  class MapThread extends Thread {
    public void run() {
      mapTheColumn();
    }
  }
  MapThread mapThread = null;
  int mapState = CellMap.UNMAPPED;


  private synchronized void needsRemap() {
    if (remap) {
      remap = false;
//System.err.println(c + " start remap ");
      colTyped = false;
      mapColumn();
//System.err.println(c + " finish remap ");
    }
  }

  private synchronized void remapNeeded() {
//System.err.println(c + " needs  remap ");
    remap = true;
  }


  private synchronized void calcStats() {
    if (recalc && mapState == CellMap.MAPPED) {
      recalc = false;
      collectStats();
    }
  }

  private synchronized void statsNeeded() {
    recalc = true;
  }

  private void collectStats() {
    double _median = 0.;
    double _q1 = 0.;
    double _q3 = 0.;
    double _mean = Double.NaN;
    double _variance = Double.NaN;
    double _stddev = Double.NaN;
    int _numNull = -1;
    int _numDistinct = -1;

    Hashtable colH = colHash;
    if (colH != null) {  // discreet values
      // num null
      Elem e = (Elem)colH.get(nullTag);
      _numNull = e != null ? e.count : 0;
      // distinct
      _numDistinct = elements != null ? elements.length : 0;
      // median and quartiles
      double _mv = (rowCount-1) / 2.; 
      double _qv1 = (Math.floor(_mv)-1) / 2.; 
      double _qv3 = rowCount - 1 - _q1; 
      for (int i = 0, c=0, nc = 0; i < elements.length; i++,c = nc) {
        nc = c + elements[i].count;
        if (c < _mv && nc + 1 > _mv) {
          if  (nc  > _mv) 
            _median = elements[i].index;
          else 
            _median = elements[i].index + .5;
        }
        if (c < _qv1 && nc + 1 > _qv1) {
          if  (nc  > _qv1) 
            _q1 = elements[i].index;
          else 
            _q1 = elements[i].index + .5;
        }
        if (c < _qv3 && nc + 1 > _qv3) {
          if  (nc  > _qv3) 
            _q3 = elements[i].index;
          else 
            _q3 = elements[i].index + .5;
        }
      }
      // mean
      _mean = 0.;
      for (int i = 0; i < elements.length; i++) {
        _mean += elements[i].index * elements[i].count / rowCount;
      }
      int n1 = rowCount - 1;
      // variance
      for (int i = 0; i < elements.length; i++) {
        _variance += (Math.pow(elements[i].index,2.) / n1) * elements[i].count;
      }
      // stddev
      _stddev = 0.;
      if (!Double.isNaN(variance) && !Double.isInfinite(variance)) {
        _stddev = Math.sqrt(variance);
      } 
    } else {
      double vals[] = new double[tm.getRowCount()];
      System.arraycopy(dvals,0,vals,0,vals.length);
      Arrays.sort(vals); // JDK1.2
      // num null
      _numNull = 0;
      for (int i = 0; i < vals.length; i++) {
        if (Double.isNaN(dvals[i])) 
          _numNull++;
      }
      // distinct
      _numDistinct = vals.length - _numNull > 0 ? 1 : 0;
      for (int i = 1; i < vals.length; i++) {
        if (vals[i] != vals[i-1])  
          _numDistinct++;
      }
      // median and quartiles
      // What about NaN INFINITY?  Should this exclude NaN INFINITY?
      if (vals.length % 2 == 0) {
         _median = (vals[vals.length/2-1] + vals[vals.length/2]) / 2. ;
         if (vals.length / 2 % 2 == 0) {
           _q1 = (vals[vals.length/4-1] + vals[vals.length/4] ) / 2.;
           _q3 = (vals[vals.length*3/4-1] + vals[vals.length*3/4] ) / 2.;
         } else {
           _q1 = vals[vals.length/4];
           _q3 = vals[vals.length*3/4];
         }
      } else {
         _median = vals[vals.length / 2];
         if (vals.length / 2 % 2 == 0) {
           _q1 = (vals[vals.length/4-1] + vals[vals.length/4] ) / 2.;
           _q3 = (vals[vals.length*3/4-1] + vals[vals.length*3/4] ) / 2.;
         } else {
           _q1 = vals[vals.length/4];
           _q3 = vals[vals.length*3/4];
         }
      }
      // mean
      _mean = 0.;
      int n = vals.length - _numNull;
      for (int i = 0; i < vals.length; i++) {
        if (!Double.isNaN(vals[i])) {
          _mean += vals[i] / n;
        }
      }
      // variance
      _variance = 0.;
      _stddev = 0.;
      double n1 = n - 1;
      if (n1 > 0) {
        for (int i = 0; i < vals.length; i++) {
          if (!Double.isNaN(vals[i])) {
            _variance += Math.pow(vals[i]-_mean,2.) / n1 ;
          }
        }
      }
      // stddev
      _stddev = Math.sqrt(_variance);
    }
    numNull = _numNull;
    numDistinct = _numDistinct;
    median = _median;
    q1 = _q1;
    q3 = _q3;
    mean = _mean;
    variance = _variance;
    stddev = _stddev;
  }

  /** 
   * Map the rows in the given column of the table to numeric values. 
   * @param tableModel the table containing the column of values
   * @param column the index of the column in the TableModel
   */
  public DefaultColumnMap(TableModel tableModel, int column) {
    this.c = column;
    setTableModel(tableModel);
  }
  /**
   * Map the rows in the given column of the table to numeric values. 
   * If mapNumbers is false, the distinct values of the column will 
   * by mapped as discreet set elements as if they were not numeric.
   * @param tableModel the table containing the column of values
   * @param column the column in the table to map.
   * @param continuous if true map numeric and date values as a real number 
   *       in the range of values from the column, if false treat numbers as 
   *       elements of a set.
   */
  public DefaultColumnMap(TableModel tableModel, int column, 
                          boolean continuous) {
    this.c = column;
    setMapping(continuous);
    setTableModel(tableModel);
  }

  /**
   * Return the state of mapping.   
   * @return The state of this map.
   * @see CellMap#UNMAPPED
   * @see CellMap#MAPPING
   * @see CellMap#MAPPED
   * @see CellMap#INVALID
   */
  public int getState() {
    return mapState;
  }

  /**
   * Set the state of mapping.
   * @param mapState The mapping state of this map.
   * @see CellMap#UNMAPPED
   * @see CellMap#MAPPING
   * @see CellMap#MAPPED
   * @see CellMap#INVALID
   */
  protected void setState(int mapState) {
    this.mapState = mapState;
  }

  /**
   * Set the default sorting order for this CellMap Class.
   * The implementing class needs to store this in a static variable.
   * @param sortOrder the default sorting order for this CellMap Class.
   */
  public void setDefaultSortOrder(int sortOrder) {
    defaultsortby = sortOrder;
  }
  /**
   * Return the default sorting order for this CellMap Class.
   * @return the default sorting order for this CellMap Class.
   */
  public int getDefaultSortOrder() {
    return defaultsortby;
  }

  /**
   * Set whether to map Number and Dates values on a continuum
   * or as a set of discreet elements.
   */
  public void setMapping(boolean continuous) {
    tryNumber = continuous;
  }
  /**
   * Return whether Number and Dates values are mapped on a continuum
   * or as a set of discreet elements.
   */
  public boolean getMapping() {
    return tryNumber;
  }

  /**
   * Sets tableModel as the data model for the column being mapped.
   * @param tableModel the data model
   */
  public void setTableModel(TableModel tableModel) {
    if (tm != null) {
      tm.removeTableModelListener(this);
    }
    tm = tableModel;
    tm.addTableModelListener(this);
    mapColumn();
  }

  /** Return the table model being displayed.
   * @return the table being displayed.
   */
  public TableModel getTableModel() {
    return tm;
  }
  /** 
   * Return the column index that is be mapped.
   * @return the index of the column of the TableModel this maps.
   */
  public int getColumnIndex() {
    return c;
  }
  /**
   * Return the Class of the column in the TableModel.
   * @return the Class of the column in the TableModel.
   */
  public Class getColumnClass() {
    if (colClass != null) {
      return colClass;
    }
    if (tm != null && c < tm.getColumnCount()) {
      return tm.getColumnClass(c);
    }
    return java.lang.Object.class;
  }

  /**
   * Return the value for this column in the TableModel at the given rowIndex.
   * This is a convenience method for TableModel.getValueAt(int rowIndex, int columnIndex),
   * however, an implementation may choose to store the values outside of the table.
   * @param rowIndex the row index in the TableModel.
   * @return the value for this column in the TableModel at the given rowIndex.
   */
  public Object getValueAt(int rowIndex) {
    if (tm != null) {
      return  tm.getValueAt(rowIndex, c);
    }
    return null;
  }

  /**
   * Return a count of the rows in the TableModel for this ColumnMap.
   * @return a count of the rows in the TableModel.
   */
  public int getCount() {
    needsRemap();
    return rowCount;
  }
  /** 
   * Return the name given this column of the TableModel.
   * @return the name given this column of the TableModel
   */
  public String getName() {
    if (name != null) {
      return name;
    }
    if (tm != null && c < tm.getColumnCount()) {
      return tm.getColumnName(c);
    }
    return null;
  }
  
  /**
   * Set the name for this map.
   * @param name the name for this map.
   */
  public void setName(String name) {
    this.name = name;
  }

  /**
   * Sets the row selection model for this table to newModel and registers
   * with for listener notifications from the new selection model.
   * @param newModel the new selection model
   */
  public void setSelectionModel(ListSelectionModel newModel) {
    lsm = newModel;
  }
  /**
   * Returns the ListSelectionModel that is used to maintain row
   * selection state.
   * @return the object that provides row selection state.
   */
  public ListSelectionModel getSelectionModel() {
    return lsm;
  }

  /** 
   * Return the sorting order for mapping this column. 
   * @return the sorting order for mapping this column.
   */
  public int getSortOrder() {
    return sortby;
  }
  /** 
   * Return the sorting order for mapping this column. 
   * @param sortOrder the sorting order for mapping this column.
   */
  public void setSortOrder(int sortOrder) {
    if (sortOrder != sortby && sortOrder >= NATURALSORT 
                            && sortOrder <= ROWORDERSORT) { 
      sortby = sortOrder;
      mapColumn();
    }
  }


  public int getNullCount() {
    needsRemap();
    Hashtable colH = colHash;
    if (colH != null) {  // discreet values
      Elem e = (Elem)colH.get(nullTag);
      return e != null ? e.count : 0;
    }
    calcStats();
    return numNull;
  }
  public int getDistinctCount() {
    needsRemap();
    Hashtable colH = colHash;
    if (colH != null) {  // discreet values
      return elements != null ? elements.length : 0;
    }
    calcStats();
    return numDistinct;
  }

  public double getMedian() { // median value
    needsRemap();
    calcStats();
    return median;
  } 

/*
  public double getPercentile(double percentile) { // value at Percentile
    needsRemap();
    calcStats();
    return median;
  } 
*/

  public double getAvg() {
    needsRemap();
    calcStats();
    return mean;
  }
  public double getVariance() { // statistical variance value
    needsRemap();
    calcStats();
    return variance;
  } 
  public double getStdDev() { // standard deviation value
    needsRemap();
    calcStats();
    return stddev;
  } 

  /**
   * Return the minimum mapped value of this column.
   * @return the minimum mapped value of this column.
   */
  public double getMin() {
    needsRemap();
    return range[0];
  }
  /**
   * Return the maximum mapped value of this column.
   * @return the maximum mapped value of this column.
   */
  public double getMax() {
    needsRemap();
    return range[1];
  }
  /**
   * Return the mapped value for the given table model row.
   * return the mapped value of each row element in the column.
   */
  public double[] getMapValues() {
    needsRemap();
    double vals[];
    Hashtable colH = colHash;
    if (colH != null) {  // discreet values 
      if (dvals == null) {
        dvals = new double[getCount()];
        for (int r = 0; r < dvals.length; r++) {
          dvals[r] = getMapValue(r);
        }
      }
    }
    vals = dvals;
    if (vals == null) {
      vals = new double[getCount()];
    }
    return vals;
  }
  /**
   * Return the mapped value for the given table model row.
   * @param row the row in the table
   * return the mapped value of the row 
   */
  public double getMapValue(int row) {
    if (row < 0 || row >= getCount()) 
      return Double.NaN;
    needsRemap();
    if (getState() != CellMap.MAPPED) 
      return Double.NaN;
    Hashtable colH = colHash;
    if (colH != null) {  // discreet values 
      Object obj = tm.getValueAt(row,c);
      if (obj == null) {
        obj = nullTag;
      }
      try {
        double d = (double)((Elem)colH.get(obj)).index;
        return d;
      } catch (Exception ex) {
        System.err.println( "err at (" + row + "," + c + ")  of " + tm.getRowCount() + " map " +  obj + " to " + colH.get(obj) + "  mappingstate: " + getState());
        
        return Double.NaN;
      }
    } else {                // a range of numeric values
      if (dvals != null) {
        if (row < dvals.length)
          return dvals[row];
        return Double.NaN;
      }
      try {
        return ((Number)tm.getValueAt(row,c)).doubleValue();
      } catch (Exception ex) {
      }
      return Double.NaN;
    }
  }

  /**
   * Return the element that is mapped nearest to the the mapValue in the 
   * given direction.
   * @param mapValue the relative position on the map 
   * @param dir negative means round down, positive mean round up, 
   *            0 rounds to closest..
   * return the element that is mapped nearest to the the mapValue.
   */
  public Object getMappedValue(double mapValue, int dir) {
    needsRemap();
    Hashtable colH = colHash;
    if (colH != null) {  // discreet values
      int i = -1;
      if (!Double.isNaN(mapValue)) {
        i = dir < 0 ? (int)Math.floor(mapValue) : 
             dir > 0 ? (int)Math.ceil(mapValue) : 
             (int)Math.round(mapValue);
      }
      if (elements != null && elements.length > 0) {
        if (i < 0) {
          i = 0;
        } else if (i >= elements.length) {
          i = elements.length - 1;
        }
        return elements[i].obj != nullTag ? elements[i].obj : null;
      } 
    } else {                // a range of numeric values
      if (isNumber) {
        DecimalFormat df = new DecimalFormat();
        ParsePosition pp = new ParsePosition(0);
        Number n = df.parse((new Double(mapValue)).toString(), pp);
        return n;
      } else if (isDate) {
        return new Date((long)mapValue);
      }
    }
    return null;
  }
  /** 
   * Construct a histogram returning the count of elements 
   * in each subrange along the ColumnMap.
   * @param buckets the number of divisions of the range of values.  If 
   * the value is zero, the default numbers of subdivisions be returned:
   * 10 if the column is numeric, else the number of discrete elements.
   * @param withSelectCounts 
   * @return an array of count of elements in each range.
   */
  public int[] getCounts(int buckets, boolean withSelectCounts) {
    needsRemap();
    if (c >= tm.getColumnCount()) {
      return new int[0];
    }
    boolean selectCount = withSelectCounts && lsm != null;
    int offset = selectCount ? 2 : 1;
    int b[] = null;
    Hashtable colH = colHash;
    if (colH != null) {
      if (buckets < 1) {
        int len = colH.size() * offset;
        b = new int[len];      
        for( Enumeration e = colH.elements(); e.hasMoreElements() ;) {
          Elem el = (Elem)e.nextElement();
          b[el.index*offset] = el.count;
        }
        if (selectCount) {
          int nrows = tm.getRowCount();
          for (int r = 0; r < nrows; r++) {
            if (lsm.isSelectedIndex(r)) {
              Object obj = tm.getValueAt(r,c);
              if (obj != null) {
                int i = ((Elem)colH.get(obj)).index * offset;
                b[i+1]++;
              }
            }
          }
        }
      } else {
        // not implemented yet, so default to:
        return getCounts(0, withSelectCounts);
      }
    } else {
      int len = buckets > 0 ? buckets : 10;
      double incr = (range[1] - range[0]) / len;
      b = new int[len*offset];
      int nrows = dvals != null ? dvals.length : tm.getRowCount();
      double val = Double.NaN;
      for (int r = 0; r < nrows; r++) {
        if (dvals != null) {
          val = dvals[r];
        } else {
          Object o = tm.getValueAt(r,c);
          if (o instanceof Number) {
            val = ((Number)o).doubleValue();
          } else {
            val = Double.NaN;
          }
        }
        if (Double.isNaN(val) || Double.isInfinite(val))
          continue;
        int i = (int)((val - range[0]) / incr);
        if (i >= buckets)
          i = buckets-1;
        if (i < 0)
          i = 0;
        b[i*offset]++;
        if (selectCount) {
          if (lsm.isSelectedIndex(r)) {
            b[i*offset+1]++;
          }
        }
      }
    }
    return b;
  }

  public ColumnMapBinModel getBinModel() {
    return new ColumnMapBinModel(this);
  }

  public static int[] getCounts(TableModel tm, ListSelectionModel lsm, 
                                ColumnMapBinModel[] bins, boolean withSelectCounts) {
    if (bins == null || bins.length < 1 || bins[0] == null) 
       return null;
    int len = bins[0].getBinCount();
    for (int i = 1; i < bins.length; i++) {
      len *= bins[i].getBinCount();
    }
    boolean selectCount = withSelectCounts && lsm != null;
    int offset = selectCount ? 2 : 1;
    int b[] = new int[len*offset];
    double val = Double.NaN;
    int nrows = tm.getRowCount();
    for (int r = 0; r < nrows; r++) {
      int idx = 0;
      for (int c = 0; c < bins.length; c++) {
        int ci = bins[c].getBin(val);
        if (ci < 0) {
          idx = ci;
          break;
        } else {
          idx += bins[c].getBinCount() * ci;
        }
      }
      if (idx >= 0 && idx < len) {
        b[idx*offset]++;
        if (selectCount) {
          if (lsm.isSelectedIndex(r)) {
            b[idx*offset+1]++;
          }
        }
      }
    }
    return b;
  }

  /** 
   * Return whether all values in this column are number values.
   * @return the number of rows that are Number values, or -1 if there is a non-number.
   */
  private int parseNumbers(int fi, int ti, double nv[][]) {
    int nrows = tm.getRowCount();
    double dv[] = new double[ti - fi + 1];
    double dr[] = new double[2]; 
    dr[0] = Double.POSITIVE_INFINITY;
    dr[1] = Double.NEGATIVE_INFINITY;
    int nums = 0;
    for (int r = fi,i = 0; r <= ti; r++,i++) {
      Object o = tm.getValueAt(r,c);
      if (o == null) {
        dv[i] = Double.NaN;
        continue;
      }
      if (o instanceof Number) {
        nums++;
        double val = ((Number)o).doubleValue();
        dv[i] = val;
        if (val > dr[1]) {
          dr[1] = val;
        } if (val <  dr[0]) {
          dr[0] = val;
        }
      } else {
        return -1;
      }
    }
    nv[0] = dv;
    nv[1] = dr;
    return nums;
  }

  /** 
   * Return whether all values in this column are Date values.
   * @return the number of rows that are Date values, or -1 if there is a non-date.
   */
  private int parseDates(int fi, int ti, double nv[][]) {
    int nrows = tm.getRowCount();
    double dv[] = new double[ti - fi + 1];
    double dr[] = new double[2]; 
    dr[0] = Double.POSITIVE_INFINITY;
    dr[1] = Double.NEGATIVE_INFINITY;
    int nums = 0;
    for (int r = fi,i = 0; r <= ti; r++,i++) {
      Object o = tm.getValueAt(r,c);
      if (o == null) {
        dv[i] = Double.NaN;
        continue;
      }
      if (o instanceof Calendar) {
        o = ((Calendar)o).getTime();
      }
      if (o instanceof Date) {
        nums++;
        double val = (double)((Date)o).getTime();
        dv[i] = val;
        if (val > dr[1]) {
          dr[1] = val;
        } else if (val <  dr[0]) {
          dr[0] = val;
        }
//System.err.println("Date "+(Date)o+" "+((Date)o).getTime()+" " +val );
      } else {
        return -1;
      }
    }
    nv[0] = dv;
    nv[1] = dr;
    return nums;
  }

  /** 
   * Return whether all values in this column are number values.
   * @return true if all values in this column are number values, else false.
   */
  public boolean isNumber() {
    needsRemap();
    return isNumber;
  }

  /** 
   * Return whether all values in this column are Dates.
   * @return true if all values in this column are Dates, else false.
   */
  public boolean isDate() {
    needsRemap();
    return isDate;
  }

  

  /**
   * If the given column of elements in the table is not numeric, 
   * map the objects to integral values from 0 to 1 less than the number 
   * of distinct elements in the column(as determined by the equals 
   * method of the object class of the column.)
   */
  private void mapColumn() {
    int nrows = tm.getRowCount();
    if (nrows < 1) {
      return;
    }
    if (async && mapThread != null) {
      mapThread.interrupt();
      mapThread = null;
    }
    isNumber = false;
    isDate = false;
    dvals = null;
    colHash = null;
    elements = null;
    if (tm != null && tm.getRowCount() > 0) {
      if (async) {
        mapThread = new MapThread();
        mapThread.setPriority((Thread.MAX_PRIORITY - Thread.MIN_PRIORITY) / 3);
        mapState = CellMap.MAPPING;
        mapThread.start();
      } else {
        mapTheColumn();
      }
    }
  }

  private void mapTheColumn() {
long t0 = System.currentTimeMillis(); 
//System.err.println("mapTheColumn " + c + "\tstart");
    int nrows = tm.getRowCount();
    if (nrows < 1) {
      return;
    }
    isNumber = false;
    isDate = false;
    dvals = null;
    colHash = null;
    elements = null;
    if (tm != null && tm.getRowCount() > 0) {
      fireColumnMapChanged(CellMap.MAPPING);
      double nv[][] = new double[2][];
      int nums = -1;
      if (tryNumber) {
        nums = parseDates(0,nrows-1,nv);
        if (nums > 0) {
          colTyped = true;
          isNumber = false;
          isDate = true;
          dvals = nv[0];
          range = nv[1];
          rowCount = dvals.length;
        } else { 
          nums = parseNumbers(0,nrows-1,nv);
        }
      }
      if (nums < 0) {         // at least one not null value was not a number
        colTyped = true;
        isNumber = false;
        isDate = false;
        dvals = null;
        colHash = new Hashtable();
        mapObjects(0,nrows - 1); 
      } else if (nums == 0) { // all null values 
        colTyped = false;
        isNumber = false;
        isDate = false;
        mapObjects(0,0); // create a single NULL entry and then adjust count
        if (elements != null && elements.length > 0) {
          elements[0].count = nrows;
        }
        rowCount = nrows;
      } else {                // any not null value is a number 
        colTyped = true;
        isNumber = true;
        isDate = false;
        dvals = nv[0];
        range = nv[1];
        rowCount = nrows;
      }
      mapState = CellMap.MAPPED;
long t1 = System.currentTimeMillis(); 
//System.err.println("mapTheColumn " + c + "\tdone " + (t1-t0));
      fireColumnMapChanged(CellMap.MAPPED);
    }
    mapThread = null;
   }


  /**
   * If the given column of elements in the table is not numeric, 
   * map the objects to integral values from 0 to 1 less than the number 
   * of distinct elements in the column(as determined by the equals 
   * method of the object class of the column.)
   */
  private void mapObjects(int from, int to) {
    int nrows = tm.getRowCount();
    if (nrows < from) {
      return;
    }
    if (colHash == null) {
      colHash = new Hashtable();
    }
    for (int r = from; r <= to; r++) {
      Object val = tm.getValueAt(r,c);
      if (val == null) {
        val = nullTag;
      }
      Elem el = (Elem)colHash.get(val);
      if (el == null) {
        el = new Elem(colHash.size());
        el.obj = val;
        colHash.put(val,el);
      }
      el.count++;
    }
    // sort the values
    if (sortby != ROWORDERSORT) {
      Object cells[] = new Object[colHash.size()]; 
      int i = 0;
      for( Enumeration e = colHash.keys(); e.hasMoreElements() ;) {
        cells[i++] = e.nextElement();
      }
      switch (sortby) {
      case ALPHANUMSORT:
        cells = Cells.sort(cells,Cells.alphaNumericComparator); 
        break;
      default:
        cells = Cells.sort(cells); 
        break;
      }
      i = -1;
      for (int vi = 0; vi < cells.length; vi++) {
        Object val = cells[vi];
        Elem el = (Elem)colHash.get(val);
        el.index = ++i;
      }
    }
    elements = new Elem[colHash.size()];
    for( Enumeration e = colHash.elements(); e.hasMoreElements() ;) {
      Elem el = (Elem)e.nextElement();
      elements[el.index] = el;
    }
    range[0] = 0.;
    range[1] = colHash.size() - 1;
    rowCount = to+1;
  }


  public void destroy() {
    setState(CellMap.INVALID);
    if (tm != null)
      tm.removeTableModelListener(this);
    elements = null;
    colHash = null;
    dvals = null;
    tm = null;
    lsm = null;
    fireColumnMapChanged(CellMap.INVALID);
  }

  /**
   * The TableModelEvent should be constructed in the coordinate system of
   * the table model.
   * @param e the change to the data model
   */
  public void tableChanged(TableModelEvent e) {
    if (e == null || e.getFirstRow() == TableModelEvent.HEADER_ROW) {
      // The whole thing changed, the class including this should handle this
      // by disposing this ColumnMap and creating new ones.
      //System.err.println("\n" + c + "HEADER_ROW ");
      destroy();
      return;
    } else if (e.getColumn() == c || 
               e.getColumn() == TableModelEvent.ALL_COLUMNS) {
      int rs = e.getFirstRow();
      int re = e.getLastRow();
      switch(e.getType()) {
      case TableModelEvent.UPDATE:
System.err.println("\n" +c + "UPDATE: " + rs + "-" + re);
        // todo see if changed row is consistent with numeric/date determination
        // if numeric/date compare to min and max.
        // if non numeric check hashed values, set min max accordingly 
        if (!colTyped) {
          remapNeeded();  
        } else if (isNumber || isDate) {
          double nv[][] = new double[2][];
          if ( (isDate && (parseDates(rs,re,nv) >= 0))  || 
               (isNumber && (parseNumbers(rs,re,nv) >= 0)) ) { 
            double dv[] = nv[0];
            double dr[] = nv[1];
            if (dvals != null && dv != null && re < dvals.length) {
              System.arraycopy(dv, 0, dvals, rs, re - rs + 1);
              statsNeeded();
              break;
            }
          } else {
            remapNeeded();  
          }
        // if non numeric check hashed values, set min max accordingly 
        } else {
        }
        remapNeeded();  
        break;
      case TableModelEvent.INSERT:
System.err.println("\n" +c + "INSERT: " + rs + "-" + re);
        // todo see if changed row is consistent with numeric determination
        // if numeric compare to min and max.
        if (!colTyped) {
          remapNeeded();  
        } else if (isNumber || isDate) {
          double nv[][] = new double[2][];
          if ( (isDate && (parseDates(rs,re,nv) >= 0))  || 
               (isNumber && (parseNumbers(rs,re,nv) >= 0)) ) { 
            double dv[] = nv[0];
            double dr[] = nv[1];
            if (dv != null) {
              if (dvals == null && rs == 0) {
                dvals = dv;
              } else {
                if (dvals == null) {
                  dvals = new double[re + 1];
                } else if (dvals.length < re+1) {
                  double tmp[] = dvals;
                  dvals = new double[re + 1];
                  System.arraycopy(tmp, 0, dvals, 0, tmp.length);
                }
                System.arraycopy(dv, 0, dvals, rs, re - rs + 1);
              }
              if (dr != null) {
                if (dr[0] < range[0]) 
                  range[0] = dr[0];
                if (dr[1] > range[1]) 
                  range[1] = dr[1];
              }
              rowCount = dvals.length;
              break;
            }
          } else {
            remapNeeded();  
          }
        // if non numeric check hashed values, set min max accordingly 
        } else {
          mapObjects(rs,re);  
        }
        break;
      case TableModelEvent.DELETE:
System.err.println("\n" +c + "DELETE: " + rs + "-" + re);
        // if non numeric, see if this eliminates a distinct value in Hashtable
        // see if change to min or max
        // for now just remap for everything
        remapNeeded();  
        break;
      }
    }
  }

  /**
   * Set the selection set operator to use when combining the current set of
   * selected values with the previous set of selected values.
   * @see SetOperator#REPLACE
   * @see SetOperator#BRUSHOVER
   * @see SetOperator#UNION
   * @see SetOperator#INTERSECTION
   * @see SetOperator#DIFFERENCE
   * @see SetOperator#XOR
   */
  public void setSetOperator(int setOperator) {
    this.setOperator = setOperator;
  }
  /**
   * Return the selection set operator in effect for combining a new set 
   * of selected values with the previous set of selected values. 
   * @return the current selection set operator being used
   */
  public int getSetOperator() {
    return setOperator;
  }

  /**
   * Select the rows of the table model that are mapped in the given range 
   * of this ColumnMap.  The selected rows are set in the given 
   * ListSelection Model.
   * @param from the start of the selected range
   * @param to the end of the selected range
   * @param sm the ListSelectionModel in which to set the rows indices. 
   */
  public void selectRange(double from, double to, ListSelectionModel sm) {
//System.err.println(this + "\tselectRange\t" + from + "\t" + to + "\t" + sm);
    int nrows = tm.getRowCount();
    double cmin, cmax;
    boolean doNull = Double.isNaN(from) || Double.isNaN(to);
    boolean doInf = Double.isInfinite(from) || Double.isInfinite(to);
    boolean doPos = doInf && from > 0. || to > 0.;
    boolean doNeg = doInf && from < 0. || to < 0.;
    if (doNull) {
      cmin = Double.isNaN(from) ? Double.NEGATIVE_INFINITY : from;
      cmax = Double.isNaN(to) ? Double.NEGATIVE_INFINITY : to;
    } else if (from < to) {
      cmin = from;
      cmax = to;
    } else {
      cmin = to;
      cmax = from;
    }
    sm.clearSelection();
    sm.setValueIsAdjusting(true);
    for (int r = 0; r < nrows; r++) {
      double v = getMapValue(r);
      if ((v >= cmin && v <= cmax) || (doNull && Double.isNaN(v)) || 
          (doInf && Double.isInfinite(v) && 
          ((doPos && v > 0.) || (doNeg && v < 0.)))) { 
        sm.addSelectionInterval(r,r);
      }
    }
    sm.setValueIsAdjusting(false);
  }
  /** 
   * Select the rows of the table model that are mapped in the given range 
   * of this ColumnMap.  The selected rows are set in the ListSelection Model
   * that was set for this ColumnMap.
   * @param from the start of the selected range
   * @param to the end of the selected range
   * @see #setSetOperator
   * @see #setSelectionModel
   */
  public void selectRange(double from, double to) {
//System.err.println(this + "\tselectRange\t" + from + "\t" + to);
    double cmin, cmax;
    boolean doNull = Double.isNaN(from) || Double.isNaN(to);
    boolean doInf = Double.isInfinite(from) || Double.isInfinite(to);
    boolean doPos = doInf && from > 0. || to > 0.;
    boolean doNeg = doInf && from < 0. || to < 0.;
    if (lsm == null) {
      return;
    }
    if (doNull) {
      cmin = Double.isNaN(from) ? Double.NEGATIVE_INFINITY : from;
      cmax = Double.isNaN(to) ? Double.NEGATIVE_INFINITY : to;
    } else if (from < to) {
      cmin = from;
      cmax = to;
    } else {
      cmin = to;
      cmax = from;
    }
    ListSelectionModel lsmOld;
    int nrows = tm.getRowCount();
    lsm.setValueIsAdjusting(true);
    switch (setOperator) {
    case SetOperator.UNION:
      for (int r = 0; r < nrows; r++) {
        double v = getMapValue(r);
        if ((v >= cmin && v <= cmax) || (doNull && Double.isNaN(v)) || 
            (doInf && Double.isInfinite(v) && 
            ((doPos && v > 0.) || (doNeg && v < 0.)))) { 
          lsm.addSelectionInterval(r,r);
        }
      }
      break;
    case SetOperator.DIFFERENCE:
      for (int r = 0; r < nrows; r++) {
        double v = getMapValue(r);
          if ((v >= cmin && v <= cmax) || (doNull && Double.isNaN(v)) || 
              (doInf && Double.isInfinite(v) && 
              ((doPos && v > 0.) || (doNeg && v < 0.)))) { 
          lsm.removeSelectionInterval(r,r);
        }
      }
      break;
    case SetOperator.INTERSECTION:
      if (lsm.getMinSelectionIndex() < 0) {
        break;
      }
      try {
        lsmOld = (DefaultListSelectionModel)
                 ((DefaultListSelectionModel)lsm).clone();
      } catch (Exception ex) {
        int min = lsm.getMinSelectionIndex();
        int max = lsm.getMaxSelectionIndex();
        lsmOld = new DefaultListSelectionModel();
        if (min >= 0) {
          for (int i = min; i <= max; i++) { 
            if (lsm.isSelectedIndex(i)) {
              lsmOld.addSelectionInterval(i,i);
            }
          }
        }
      }
      lsm.clearSelection();
      for (int r = 0; r < nrows; r++) {
        double v = getMapValue(r);
        if ((v >= cmin && v <= cmax) || (doNull && Double.isNaN(v)) || 
            (doInf && Double.isInfinite(v) && 
            ((doPos && v > 0.) || (doNeg && v < 0.)))) { 
          if (lsmOld.isSelectedIndex(r)) {
            lsm.addSelectionInterval(r,r);
          }
        }
      }
      break;
    case SetOperator.XOR:
      if (lsm.getMinSelectionIndex() < 0) {
        for (int r = 0; r < nrows; r++) {
          double v = getMapValue(r);
          if ((v >= cmin && v <= cmax) || (doNull && Double.isNaN(v)) || 
              (doInf && Double.isInfinite(v) && 
              ((doPos && v > 0.) || (doNeg && v < 0.)))) { 
            lsm.addSelectionInterval(r,r);
          }
        }
        break;
      }
      try {
        lsmOld = (DefaultListSelectionModel)
                 ((DefaultListSelectionModel)lsm).clone();
      } catch (Exception ex) {
        int min = lsm.getMinSelectionIndex();
        int max = lsm.getMaxSelectionIndex();
        lsmOld = new DefaultListSelectionModel();
        if (min >= 0) {
          for (int i = min; i <= max; i++) { 
            if (lsm.isSelectedIndex(i)) {
              lsmOld.addSelectionInterval(i,i);
            }
          }
        }
      }
      for (int r = 0; r < nrows; r++) {
        double v = getMapValue(r);
        if ((v >= cmin && v <= cmax) || (doNull && Double.isNaN(v)) || 
            (doInf && Double.isInfinite(v) && 
            ((doPos && v > 0.) || (doNeg && v < 0.)))) { 
          if (lsmOld.isSelectedIndex(r)) {
            lsm.removeSelectionInterval(r,r);
          } else {
            lsm.addSelectionInterval(r,r);
          }
        }
      }
      break; 
    case SetOperator.BRUSHOVER:
    case SetOperator.REPLACE:
      lsm.clearSelection();
      for (int r = 0; r < nrows; r++) {
        double v = getMapValue(r);
        if ((v >= cmin && v <= cmax) || (doNull && Double.isNaN(v)) || 
            (doInf && Double.isInfinite(v) && 
            ((doPos && v > 0.) || (doNeg && v < 0.)))) { 
          lsm.addSelectionInterval(r,r);
        }
      }
      break;
    }
    lsm.setValueIsAdjusting(false);
  }

  /** 
   * Apply the given selection to the current selection for this column,
   * using the setOperator currently in effect.
   * @param selection the selected rows to combine with the previous selection
   * @see #setSetOperator
   * @see #setSelectionModel
   */
  public void selectValues(ListSelectionModel selection) {
    double cmin, cmax;
    if (lsm == null || selection ==null) {
      return;
    }
    int nrows = tm.getRowCount();
    int min = selection.getMinSelectionIndex();
    int max = selection.getMaxSelectionIndex();
    lsm.setValueIsAdjusting(true);
    switch (setOperator) {
    case SetOperator.UNION:
      if (min < 0)
        break;
      for (int r = min; r <= max; r++) {
        if (selection.isSelectedIndex(r)) {
          lsm.addSelectionInterval(r,r);
        }
      }
      break;
    case SetOperator.DIFFERENCE:
      if (min < 0)
        break;
      for (int r = min; r <= max; r++) {
        if (selection.isSelectedIndex(r)) {
          lsm.removeSelectionInterval(r,r);
        }
      }
      break;
    case SetOperator.INTERSECTION:
      if (lsm.getMinSelectionIndex() < 0) 
        break;
      min = lsm.getMinSelectionIndex();
      max = lsm.getMaxSelectionIndex();
      for (int r = min; r <= max; r++) {
        if (!selection.isSelectedIndex(r)) {
          lsm.removeSelectionInterval(r,r);
        }
      }
      break;
    case SetOperator.XOR:
      if (lsm.getMinSelectionIndex() < 0) {
        for (int r = min; r <= max; r++) {
          if (!selection.isSelectedIndex(r)) {
            lsm.addSelectionInterval(r,r);
          } 
        }
        break;
      }
      for (int r = min; r <= max; r++) {
        if (selection.isSelectedIndex(r)) {
          if (lsm.isSelectedIndex(r)) {
            lsm.removeSelectionInterval(r,r);
          } else {
            lsm.addSelectionInterval(r,r);
          }
        }
      }
      break; 
    case SetOperator.BRUSHOVER:
    case SetOperator.REPLACE:
      lsm.clearSelection();
      if (min < 0)
        break;
      for (int r = min; r <= max; r++) {
        if (selection.isSelectedIndex(r)) {
          lsm.addSelectionInterval(r,r);
        }
      }
      break;
    }
    lsm.setValueIsAdjusting(false);
  }


  /** 
   *  
   */
  // Now this has reference to the other ColumnMap, should use WeakHashMap?
  // Hashtable covariances = new Hashtable();
  WeakHashMap covariances = new WeakHashMap();
  public void setCovariance(CellMap map, double covariance) {
    covariances.put(map, new Double(covariance));
  }

  public double covariance(CellMap map) {
    double covariance = Double.NaN;
    Double covObj = (Double)covariances.get(map);
    if (covObj == null) {
       covariance = covariance(this, map);
       this.setCovariance(map, covariance);
       map.setCovariance(this, covariance);
    } else {
      covariance = covObj.doubleValue();
    }
    return covariance;
  }

  public double correlation(CellMap map) {
    return covariance(map) / (getStdDev() * map.getStdDev());
  }

  public double[] stdvals() {
    double vals[] = null;
    double dval[] = getMapValues();
    int cnt = dval.length;
    double mean = getAvg();
    double stddev = getStdDev();
    if (stddev != 0 && !Double.isNaN(mean) && !Double.isNaN(stddev)) {
      vals = new double[cnt];
      if (stddev == 0) {
        Arrays.fill(vals,0.);
      } else {
        for (int i = 0; i < vals.length; i++) {
          if (!Double.isNaN(dval[i])) {
            vals[i] = (dval[i] - mean) / stddev;
          } else {
            vals[i] = Double.NaN;
          }
        }
      }
    }
    return vals;
  }

  // correlation
  // r = (1/(n-1)) * sum( ((x[i] - mean) / stdvals[i])*((y[i] - mean) / stdvals[i]))

  // covariance(xmap, ymap) / (xmap.getStdDev() * ymap.getStdDev())
  public static double correlation (CellMap xmap, CellMap ymap) {
    double cov = xmap.covariance(ymap);
    return cov/(xmap.getStdDev() * ymap.getStdDev()); 
  }


  public static double covariance(CellMap xmap, CellMap ymap) {
    double cov = Double.NaN;
    double xd[] = xmap.getMapValues();
    double yd[] = ymap.getMapValues();
    if (xd != null && yd != null && xd.length > 0 && xd.length == yd.length) {
      double sumx=xd[0], sumy=yd[0], Sxy=0;
      for (int i=1; i < xd.length; i++) {
        double x = xd[i];
        double y = yd[i];
        sumx += x;
        Sxy += (x - sumx/(i+1))*(y - sumy/i);
        sumy += y;
      }
      cov = Sxy/xd.length;
      if (xd.length > 1) {
        cov *= (double)xd.length / (xd.length - 1.);
      }
      //System.err.println(xmap + " " + ymap + " " + cov);
    }
    return cov;
  }

  public LineFormula regressionLine(CellMap ymap) {
    return regressionLine(this, ymap);
  }

  public static void printArray(double a[]) {
    for (int i = 0; i < a.length && i < 20; i++) {
      System.err.print("\t" + a[i]); 
    }
    System.err.println("");
  }

  // least squares regression
  // Returns line class that returns a y val for a given x
  public static LineFormula regressionLine(CellMap xmap, CellMap ymap) {
    double meanx = xmap.getAvg();
    double meany = ymap.getAvg();
    double sx = xmap.getStdDev();
    double sy = ymap.getStdDev();
    double r = xmap.correlation(ymap);
    double m = r * sy / sx;
    double i = meany - m * meanx;
    return new LineFormula(m,i);
  }

/*
  public static Vector residuals(Vector xcells, Vector ycells) {
    return residuals(xcells, ycells, regressionLine(xcells, ycells));
  }
  public static Vector residuals(Vector xcells, Vector ycells,
                                   LineFormula regressionLine) {
    if (xcells == null || ycells == null || regressionLine == null)
      return null;
    Vector r = new Vector(xcells.size());
    for (int i = 0; i < xcells.size(); i++) {
      double rv = Double.NaN;
      Object xo = xcells.elementAt(i);
      if (xo != null && xo instanceof Number) {
        double x = ((Number)xo).doubleValue();
        if (!Double.isNaN(x)) {
           Object yo = ycells.elementAt(i);
           if (yo != null && yo instanceof Number) {
             double y = ((Number)yo).doubleValue();
             double ry = regressionLine.getY(x);
             rv = y - ry;
           }
        }
      }
      r.addElement(new Double(rv));
    }
    return r;
  }
*/



  public void addCellMapListener(CellMapListener l) {
    EventListener[] listeners = listenerList.getListeners(CellMapListener.class);
    for (int i = 0; i < listeners.length; i++) {
      if (listeners[i] == l) 
        return;
    }
    listenerList.add(CellMapListener.class, l);
  }

  public void removeCellMapListener(CellMapListener l) {
    listenerList.remove(CellMapListener.class, l);
  }
  protected void fireColumnMapChanged(int mapState) {
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    // Process the listeners last to first, notifying
    // those that are interested in this event
    CellMapEvent columnMapEvent = null;
    for (int i = listeners.length-2; i>=0; i-=2) {
      if (listeners[i]==CellMapListener.class) {
        // Lazily create the event:
        if (columnMapEvent == null)
          columnMapEvent = new CellMapEvent(this, mapState);
        ((CellMapListener)listeners[i+1]).cellMapChanged(columnMapEvent);
      }
    }
  }
}
